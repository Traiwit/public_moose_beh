"""
Replacement for some functionality of newer python versions not available
at version 2.4 (used by abaqus) or even earlier.

If used with a newer version of python this module does not overwrite the
probably better builtin versions.


implements:
===========

  - builtin functions all() and any() (new in python 2.5)
  - builtin types set and frozenset (new in python 2.4)
  - defaultdict type from the collections module (new in python 2.5)
  - namedtuple factory function (new in python 2.6)
  - Record class not in python standard libs
  - izip_longest, check_call, OrderedDict, Counter (add module reference!)

usage:
======

  >>> from bae.future_01 import all, any, defaultdict, izip_longest

  >>> from bae.future_01 import *

@Note: Possibly not all of the documentation for this module shows up in the
autogenerated epydoc-docs. This is because of the tricky implementation that
only defines what is missing. If in doubt look at the python source and add
corresponding Information in the module's docstring (here).
"""

__version__ = '1.14'

_version_history_ = """\
Versions:
=========

1.0 : defaultdict, all
1.1 : Exception, set, frozenset, new way of importing
1.2 : remove Exception because message attribute is deprecated in python v2.6
1.3 : namedtuple from Recipe 500261 (r15): Named Tuples
       http://code.activestate.com/recipes/500261/
1.4 : Record class from recipe 502237
       http://code.activestate.com/recipes/502237/
1.5 : GP added izip_longest
1.6 : GP added check_call
1.7 : GP added OrderedDict
1.8 : GP added Counter
1.9 : GP added OrderedDict.iterkeys, ...itervalues, to be consistent with
       python 2.7
1.10: VL added OrderedSet
1.11: GP added classproperty (not implemented in Python yet (I think).
1.12: TR added fallback for numpy.unique
1.13: TR added/copied NumpyVersion from current numpy implementation
1.14: TR added utf8Subs for utf8-compatible parsing of super- and subscripts
"""

_bugs_ = """\
None, of course.
maybe ;-)
"""

from operator import itemgetter as _itemgetter
from keyword import iskeyword as _iskeyword
import sys as _sys
import inspect

assert (_sys.version_info[0]==2 and _sys.version_info[1]>=4), \
    "Python version 2.4.xx or later is required to run the bae_utils."

#-----------------------------------
#-- defaultdict

try:
    from collections import defaultdict
except ImportError:
    class defaultdict(dict):
        """new in python 2.5 in module collections
        this is a fully functional replacement
        """
        def __init__(self, default_factory=None, *args):
            self.default_factory=default_factory
            dict.__init__(self, *args)
        def __missing__(self, key):
            if self.default_factory==None:
                new = None
            else:
                new = self.default_factory()
            self[key] = new
            return new
        def __getitem__(self, key):
            try:
                return dict.__getitem__(self, key)
            except KeyError:
                return self.__missing__(key)

#-----------------------------------
#-- namedtuple

try:
    from collections import namedtuple
except ImportError:
    def namedtuple(typename, field_names, verbose=False, rename=False):
        """Returns a new subclass of tuple with named fields.

        >>> Point = namedtuple('Point', 'x y')
        >>> Point.__doc__                   # docstring for the new class
        'Point(x, y)'
        >>> p = Point(11, y=22)             # instantiate with positional args or keywords
        >>> p[0] + p[1]                     # indexable like a plain tuple
        33
        >>> x, y = p                        # unpack like a regular tuple
        >>> x, y
        (11, 22)
        >>> p.x + p.y                       # fields also accessable by name
        33
        >>> d = p._asdict()                 # convert to a dictionary
        >>> d['x']
        11
        >>> Point(**d)                      # convert from a dictionary
        Point(x=11, y=22)
        >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields
        Point(x=100, y=22)

        @param field_names: The field_names are a single string with each
        fieldname separated by whitespace and/or commas, for example 'x y' or
        'x, y'. Alternatively, field_names can be a sequence of strings such as
        ['x', 'y'].

        Any valid Python identifier may be used for a fieldname except for
        names starting with an underscore. Valid identifiers consist of
        letters, digits, and underscores but do not start with a digit or
        underscore and cannot be a keyword such as class, for, return, global,
        pass, print, or raise.
        """

        # Parse and validate the field names.  Validation serves two purposes,
        # generating informative error messages and preventing template injection attacks.
        if isinstance(field_names, basestring):
            field_names = field_names.replace(',', ' ').split() # names separated by whitespace and/or commas
        field_names = tuple(map(str, field_names))
        if rename:
            names = list(field_names)
            seen = set()
            for i, name in enumerate(names):
                if (not min(c.isalnum() or c=='_' for c in name) or _iskeyword(name)
                    or not name or name[0].isdigit() or name.startswith('_')
                    or name in seen):
                        names[i] = '_%d' % i
                seen.add(name)
            field_names = tuple(names)
        for name in (typename,) + field_names:
            if not min(c.isalnum() or c=='_' for c in name):
                raise ValueError('Type names and field names can only contain alphanumeric characters and underscores: %r' % name)
            if _iskeyword(name):
                raise ValueError('Type names and field names cannot be a keyword: %r' % name)
            if name[0].isdigit():
                raise ValueError('Type names and field names cannot start with a number: %r' % name)
        seen_names = set()
        for name in field_names:
            if name.startswith('_') and not rename:
                raise ValueError('Field names cannot start with an underscore: %r' % name)
            if name in seen_names:
                raise ValueError('Encountered duplicate field name: %r' % name)
            seen_names.add(name)

        # Create and fill-in the class template
        numfields = len(field_names)
        argtxt = repr(field_names).replace("'", "")[1:-1]   # tuple repr without parens or quotes
        reprtxt = ', '.join('%s=%%r' % name for name in field_names)
        template = '''class %(typename)s(tuple):
        '%(typename)s(%(argtxt)s)' \n
        __slots__ = () \n
        _fields = %(field_names)r \n
        def __new__(_cls, %(argtxt)s):
            return _tuple.__new__(_cls, (%(argtxt)s)) \n
        @classmethod
        def _make(cls, iterable, new=tuple.__new__, len=len):
            'Make a new %(typename)s object from a sequence or iterable'
            result = new(cls, iterable)
            if len(result) != %(numfields)d:
                raise TypeError('Expected %(numfields)d arguments, got %%d' %% len(result))
            return result \n
        def __repr__(self):
            return '%(typename)s(%(reprtxt)s)' %% self \n
        def _asdict(self):
            'Return a new dict which maps field names to their values'
            return dict(zip(self._fields, self)) \n
        def _replace(_self, **kwds):
            'Return a new %(typename)s object replacing specified fields with new values'
            result = _self._make(map(kwds.pop, %(field_names)r, _self))
            if kwds:
                raise ValueError('Got unexpected field names: %%r' %% kwds.keys())
            return result \n
        def __getnewargs__(self):
            return tuple(self) \n\n''' % locals()
        for i, name in enumerate(field_names):
            template += '        %s = _property(_itemgetter(%d))\n' % (name, i)
        if verbose:
            print template

        # Execute the template string in a temporary namespace
        namespace = dict(_itemgetter=_itemgetter, __name__='namedtuple_%s' % typename,
                         _property=property, _tuple=tuple)
        try:
            exec template in namespace
        except SyntaxError, e:
            raise SyntaxError(e.args[0] + ':\n' + template)
        result = namespace[typename]

        # For pickling to work, the __module__ variable needs to be set to the frame
        # where the named tuple is created.  Bypass this step in enviroments where
        # sys._getframe is not defined (Jython for example) or sys._getframe is not
        # defined for arguments greater than 0 (IronPython).
        try:
            result.__module__ = _sys._getframe(1).f_globals.get('__name__', '__main__')
        except (AttributeError, ValueError):
            pass

        return result


#-----------------------------------
#-- OrderedDict

try:
    from collections import OrderedDict
except ImportError:
    class OrderedDict(dict):
        r"""
        A dict guaranteeing a certain order on iteration. The ordering of items
        is defined by the time of insertion of the key. New keys are appended
        at the end, but keys that are overwritten are not moved to the end.

        The following example shows the behavior for simple assignments:
         >>> d = OrderedDict()
         >>> d['parrot'] = 'dead'
         >>> d['penguin'] = 'exploded'
         >>> d.items()
         [('parrot', 'dead'), ('penguin', 'exploded')]

        From the reference implementation. See
        http://www.python.org/dev/peps/pep-0372/

        Note: alternative implementation found here:
        Ordered Dictionary for Py2.4 (Python recipe)
        http://code.activestate.com/recipes/576693/
        """

        __marker = object()

        def __init__(self, *args, **kwds):
            if len(args) > 1:
                raise TypeError('expected at most 1 arguments, got %d' % len(args))
            if not hasattr(self, '_keys'):
                self._keys = []
            self.update(*args, **kwds)

        def clear(self):
            del self._keys[:]
            dict.clear(self)

        def __setitem__(self, key, value):
            if key not in self:
                self._keys.append(key)
            dict.__setitem__(self, key, value)

        def __delitem__(self, key):
            dict.__delitem__(self, key)
            self._keys.remove(key)

        def __iter__(self):
            return iter(self._keys)

        def __reversed__(self):
            return reversed(self._keys)

        def popitem(self):
            if not self:
                raise KeyError('dictionary is empty')
            key = self._keys.pop()
            value = dict.pop(self, key)
            return key, value

        def __reduce__(self):
            items = [[k, self[k]] for k in self]
            inst_dict = vars(self).copy()
            inst_dict.pop('_keys', None)
            return (self.__class__, (items,), inst_dict)

        def pop(self, key, default=__marker):
            try:
                value = self[key]
            except KeyError:
                if default is self.__marker:
                    raise
                return default
            else:
                del self[key]
                return value

        def update(self, other=(), **kwds):
            if isinstance(other, dict):
                for key in other:
                    self[key] = other[key]
            elif hasattr(other, "keys"):
                for key in other.keys():
                    self[key] = other[key]
            else:
                for key, value in other:
                    self[key] = value
            for key, value in kwds.items():
                self[key] = value

        def setdefault(self, key, default=None):
            try:
                return self[key]
            except KeyError:
                self[key] = default
            return default

        def keys(self):
            return list(self)

        def items(self):
            return [(key, self[key]) for key in self]

        # added for convenience (not in the original code)
        # seems to be consistent with python 2.7 only when this part is included
        def iterkeys(self):
            return self.__iter__()
        def iteritems(self):
            return ((key, self[key]) for key in self)
        def itervalues(self):
            return (self[key] for key in self)

        def values(self):
            return [self[key] for key in self]

        def __repr__(self):
            if not self:
                return '%s()' % (self.__class__.__name__,)
            return '%s(%r)' % (self.__class__.__name__, list(self.items()))

        def copy(self):
            return self.__class__(self)

        @classmethod
        def fromkeys(cls, iterable, value=None):
            d = cls()
            for key in iterable:
                d[key] = value
            return d

        def __eq__(self, other):
            if isinstance(other, OrderedDict):
                return all(p==q for p, q in izip_longest(self.items(), other.items()))
            return dict.__eq__(self, other)

import collections

class OrderedSet(collections.MutableSet):
    r"""Set that remembers original insertion order.

    Runs on Py2.6 or later (and runs on 3.0 or later without any
    modifications).

    Implementation based on a doubly linked list and an internal
    dictionary. This design gives OrderedSet the same big-Oh running
    times as regular sets including O(1) adds, removes, and lookups
    as well as O(n) iteration.

    Example:
     >>> s = OrderedSet('abracadaba')
     >>> t = OrderedSet('simsalabim')
     >>> print(s | t)
     >>> print(s & t)
     >>> print(s - t)

    From http://code.activestate.com/recipes/576694/
    """

    def __init__(self, iterable=None):
        self.end = end = []
        end += [None, end, end]         # sentinel node for doubly linked list
        self.map = {}                   # key --> [key, prev, next]
        if iterable is not None:
            self |= iterable

    def __len__(self):
        return len(self.map)

    def __contains__(self, key):
        return key in self.map

    def add(self, key):
        if key not in self.map:
            end = self.end
            curr = end[1]
            curr[2] = end[1] = self.map[key] = [key, curr, end]

    def discard(self, key):
        if key in self.map:
            key, prev, next = self.map.pop(key)
            prev[2] = next
            next[1] = prev

    def __iter__(self):
        end = self.end
        curr = end[2]
        while curr is not end:
            yield curr[0]
            curr = curr[2]

    def __reversed__(self):
        end = self.end
        curr = end[1]
        while curr is not end:
            yield curr[0]
            curr = curr[1]

    def pop(self, last=True):
        if not self:
            raise KeyError('set is empty')
        key = self.end[1][0] if last else self.end[2][0]
        self.discard(key)
        return key

    def __repr__(self):
        if not self:
            return '%s()' % (self.__class__.__name__,)
        return '%s(%r)' % (self.__class__.__name__, list(self))

    def __eq__(self, other):
        if isinstance(other, OrderedSet):
            return len(self) == len(other) and list(self) == list(other)
        return set(self) == set(other)



#-----------------------------------
#-- Counter

try:
    from collections import Counter
except ImportError:

    ## taken from http://code.activestate.com/recipes/576611/ (r11)
    from operator import itemgetter
    from heapq import nlargest
    from itertools import repeat, ifilter

    class Counter(dict):
        '''Dict subclass for counting hashable objects.  Sometimes called a bag
        or multiset.  Elements are stored as dictionary keys and their counts
        are stored as dictionary values.

        >>> Counter('zyzygy')
        Counter({'y': 3, 'z': 2, 'g': 1})

        '''

        def __init__(self, iterable=None, **kwds):
            '''Create a new, empty Counter object.  And if given, count elements
            from an input iterable.  Or, initialize the count from another
            mapping of elements to their counts.

            >>> c = Counter()                  # a new, empty counter
            >>> c = Counter('gallahad')        # a new counter from an iterable
            >>> c = Counter({'a': 4, 'b': 2})  # a new counter from a mapping
            >>> c = Counter(a=4, b=2)          # a new counter from keyword args
            '''
            self.update(iterable, **kwds)

        def __missing__(self, key):
            return 0

        def most_common(self, n=None):
            '''List the n most common elements and their counts from the most
            common to the least.  If n is None, then list all element counts.

            >>> Counter('abracadabra').most_common(3)
            [('a', 5), ('r', 2), ('b', 2)]

            '''
            if n is None:
                return sorted(self.iteritems(), key=itemgetter(1), reverse=True)
            return nlargest(n, self.iteritems(), key=itemgetter(1))

        def elements(self):
            '''Iterator over elements repeating each as many times as its count.

            >>> c = Counter('ABCABC')
            >>> sorted(c.elements())
            ['A', 'A', 'B', 'B', 'C', 'C']

            If an element's count has been set to zero or is a negative number,
            elements() will ignore it.

            '''
            for elem, count in self.iteritems():
                for _ in repeat(None, count):
                    yield elem

        # Override dict methods where the meaning changes for Counter objects.

        @classmethod
        def fromkeys(cls, iterable, v=None):
            raise NotImplementedError(
                'Counter.fromkeys() is undefined.  Use Counter(iterable)'
                ' instead.')

        def update(self, iterable=None, **kwds):
            '''Like dict.update() but add counts instead of replacing them.

            Source can be an iterable, a dictionary, or another Counter
            instance.

            >>> c = Counter('which')
            >>> c.update('witch')           # add elements from another iterable
            >>> d = Counter('watch')
            >>> c.update(d)                 # add elements from another counter
            >>> c['h']                      # four 'h' in which,witch, and watch
            4

            '''
            if iterable is not None:
                if hasattr(iterable, 'iteritems'):
                    if self:
                        self_get = self.get
                        for elem, count in iterable.iteritems():
                            self[elem] = self_get(elem, 0) + count
                    else:
                        # fast path when counter is empty
                        dict.update(self, iterable)
                else:
                    self_get = self.get
                    for elem in iterable:
                        self[elem] = self_get(elem, 0) + 1
            if kwds:
                self.update(kwds)

        def copy(self):
            'Like dict.copy() but returns a Counter instance instead of a dict.'
            return Counter(self)

        def __delitem__(self, elem):
            'Like dict.__delitem__() but does not raise KeyError for missing'
            ' values.'
            if elem in self:
                dict.__delitem__(self, elem)

        def __repr__(self):
            if not self:
                return '%s()' % self.__class__.__name__
            items = ', '.join(map('%r: %r'.__mod__, self.most_common()))
            return '%s({%s})' % (self.__class__.__name__, items)

        # Multiset-style mathematical operations discussed in:
        #       Knuth TAOCP Volume II section 4.6.3 exercise 19
        #       and at http://en.wikipedia.org/wiki/Multiset
        #
        # Outputs guaranteed to only include positive counts.
        #
        # To strip negative and zero counts, add-in an empty counter:
        #       c += Counter()

        def __add__(self, other):
            '''Add counts from two counters.

            >>> Counter('abbb') + Counter('bcc')
            Counter({'b': 4, 'c': 2, 'a': 1})


            '''
            if not isinstance(other, Counter):
                return NotImplemented
            result = Counter()
            for elem in set(self) | set(other):
                newcount = self[elem] + other[elem]
                if newcount > 0:
                    result[elem] = newcount
            return result

        def __sub__(self, other):
            ''' Subtract count, but keep only results with positive counts.

            >>> Counter('abbbc') - Counter('bccd')
            Counter({'b': 2, 'a': 1})

            '''
            if not isinstance(other, Counter):
                return NotImplemented
            result = Counter()
            for elem in set(self) | set(other):
                newcount = self[elem] - other[elem]
                if newcount > 0:
                    result[elem] = newcount
            return result

        def __or__(self, other):
            '''Union is the maximum of value in either of the input counters.

            >>> Counter('abbb') | Counter('bcc')
            Counter({'b': 3, 'c': 2, 'a': 1})

            '''
            if not isinstance(other, Counter):
                return NotImplemented
            _max = max
            result = Counter()
            for elem in set(self) | set(other):
                newcount = _max(self[elem], other[elem])
                if newcount > 0:
                    result[elem] = newcount
            return result

        def __and__(self, other):
            ''' Intersection is the minimum of corresponding counts.

            >>> Counter('abbb') & Counter('bcc')
            Counter({'b': 1})

            '''
            if not isinstance(other, Counter):
                return NotImplemented
            _min = min
            result = Counter()
            if len(self) < len(other):
                self, other = other, self
            for elem in ifilter(self.__contains__, other):
                newcount = _min(self[elem], other[elem])
                if newcount > 0:
                    result[elem] = newcount
            return result


#-----------------------------------
#-- Record class

## {{{ Recipe 502237 (r6): Simple record (a.k.a. struct) type
class InitFromSlots(type):
    def __new__(meta, name, bases, bodydict):
        slots = bodydict['__slots__']
        if slots and '__init__' not in bodydict:
            parts = ['def __init__(self, %s):' % ', '.join(slots)]
            for slot in slots:
                parts.append('    self.%s = %s' % (slot, slot))
            exec '\n'.join(parts) in bodydict
        super_new = super(InitFromSlots, meta).__new__
        return super_new(meta, name, bases, bodydict)

class Record(object):
    """Simple record (a.k.a. struct) type where each argument to the
    constructor becomes an attribute of the object.

    >>> class Point(Record):
    ...     __slots__ = 'x', 'y'
    ...
    >>> Point(3, 4)
    Point(x=3, y=4)
    >>> Point(y=5, x=2)
    Point(x=2, y=5)
    >>> point = Point(-1, 42)
    >>> point.x, point.y
    (-1, 42)
    >>> x, y = point
    >>> x, y
    (-1, 42)
    """
    __metaclass__ = InitFromSlots
    __slots__ = ()
    def _items(self):
        for name in self.__slots__:
            yield name, getattr(self, name)
    def __repr__(self):
        args = ', '.join('%s=%r' % tup for tup in self._items())
        return '%s(%s)' % (type(self).__name__, args)
    def __iter__(self):
        for name in self.__slots__:
            yield getattr(self, name)
    def __getstate__(self):
        return dict(self._items())
    def __setstate__(self, statedict):
        self.__init__(**statedict)


#-----------------------------------
#-- all

try:
    # this works only if this script is imported as a module
    func_all_defined = 'all' in __builtins__
except TypeError:
    # this works only if this script is run as the main program
    func_all_defined =  hasattr(__builtins__, "all")

if func_all_defined:
    all = all # in case you do: from bae.future_01 import all
else:
    def all(iterable):
        """new builtin in python 2.5
        This code is taken from the python docs"""
        for element in iterable:
            if not element:
                return False
        return True


#-----------------------------------
#-- any

try:
    # this works only if this script is imported as a module
    func_any_defined = 'any' in __builtins__
except TypeError:
    # this works only if this script is run as the main program
    func_any_defined = hasattr(__builtins__, "any")

if func_any_defined:
    any = any  # in case you do: from bae.future_01 import any
else:
    def any(iterable):
        """new builtin in python 2.5
        This code is taken from the python docs"""
        for element in iterable:
            if element:
                return True
        return False


#-----------------------------------
#-- set, frozenset

try:
    # this works only if this script is imported as a module
    func_all_defined = 'set' in __builtins__
except TypeError:
    # this works only if this script is run as the main program
    func_all_defined = hasattr(__builtins__, "set")

if func_all_defined:
    # in case you do: from bae.future_01 import set, frozenset
    set = set
    frozenset = frozenset
else:
    from sets import Set as set, ImmutableSet as frozenset



#-----------------------------------
#-- izip_longest from itertools (new in 2.6)

try:
    from itertools import izip_longest
except ImportError:
    # from http://docs.python.org/library/itertools.html#itertools.izip_longest
    from itertools import chain, izip
    def izip_longest(*args, **kwds):
        # izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-
        fillvalue = kwds.get('fillvalue')
        def sentinel(counter = ([fillvalue]*(len(args)-1)).pop):
            yield counter()         # yields the fillvalue, or raises IndexError
        fillers = repeat(fillvalue)
        iters = [chain(it, sentinel(), fillers) for it in args]
        try:
            for tup in izip(*iters):
                yield tup
        except IndexError:
            pass

#-----------------------------------
#--  subprocess.check_call

try:
    from subprocess import check_call, CalledProcessError
except ImportError:
    class CalledProcessError(Exception):
        def __str__(self):
            return ("Command '%s' returned non-zero exit status %s"
                    % (self.args[1], self.args[0] ))

    def check_call(*args, **kwargs):
        from subprocess import call
        retcode = call(*args, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = args[0]
            raise CalledProcessError(retcode, cmd)
        return 0


#-----------------------------------
#--  classproperty

class classproperty(object):
    """This is a simple implementation of a decorator to create a read only
    class property. This can be used for lazy initialization i.e. initialize
    a class property only when it's needed for the first time.

    Usage:
     >>> class C(object):
     >>>     _i = None
     >>>     @classproperty
     >>>     def i(cls):
     >>>         if cls._i is None:
     >>>             print "initializing i"
     >>>             cls._i = 10
     >>>         return cls._i
     >>> c = C()
     >>> print c.i
     initializing i
     10
     >>> d = C()
     >>> print d.i
     10

    Note that accessing the property takes more time than accessing a member
    attribute because it's a function evaluation after all.

    Here is a solution that doesn't need the classproperty feature and
    overcomes the performance penalty:
     >>> class C(object):
     >>>     @property
     >>>     def i(cls):
     >>>         print "initializing i"
     >>>         C.i = 10  # overwrite (property) method with value
     >>>         return cls.i
     >>> c = C()
     >>> print c.i
     initializing i
     10
     >>> d = C()
     >>> print d.i
     10

    Note however that before accessing the instance attribute c.i for the first
    time the class attribute C.i is a property method. I.e. you can't access
    reliably the value as a class attribute.

    Source:
    U{https://stackoverflow.com/questions/5189699/how-to-make-a-class-property}
    and
    U{https://stackoverflow.com/questions/128573/using-property-on-classmethods}
    """
    def __init__(self, f):
        self.f = f

    def __get__(self, obj, owner):
        return self.f(owner)


#-----------------------------------
#--  numpy fallbacks

try:
    import numpy as np
except ImportError:
    # Don't supply functions that rely on numpy if numpy is not there.
    # "from bae.future_01 import ..." will raise an ImportError
    pass
else:

    def _uniqueFrequencies(index, inverse):
        '''Counts the number of values from index in inverse. This mimics the
        return_counts-argument of unique in newer numpyversion. So it is
        assumed that:
            - index only holds unique values (indexes)
            - inverse holds all/only indexes from index
        @note: this is only a slow, straight forward fallback solution
        '''

        cnts = np.zeros(index.shape, dtype=int)
        for ii, idx in enumerate(index):
            cnts[ii] = (inverse==ii).sum()

        return cnts

    def uniqueRows(a, return_index=False, return_inverse=False,
                   return_counts=False, axis=None):
        """Replacement for numpy.unique if we have an old numpy version.
        This implementation takes the same optional arguments as current
        implementations of unique since numpy version 1.13.0

        Optional arguments not supported before 1.13.0
            - axis: specifies the axis allong the entries will be compared
            - return_counts: (new since 1.9.0) counts the number/frequency

        Emulates the axis-kwarg by transforming the numpy-array into a
        structured numpy-array.

        Axis-kwarg can be None (unique values in array) or 1 (unique rows).
        Other values for axis can be mimicked by swaping axis manually.

        @Note: The order of returned fields is differently sorted than in
        newer numpy-versions. If you need exactly the same behaviour you'll
        need to apply np.argsort to the array returned as first item and to
        swap/replace the indices in the other fields accordingly.
        """
        if (axis is not None) and (axis != 0):
            raise ValueError(
                "The keyword argument axis is fully supported since numpy"
                " 1.13.0. For older versions only axis=None (default) or"
                " axis=0 is implemented as a workaround.")

        version = NumpyVersion(np.__version__)
        #version = NumpyVersion('1.8.0')

        uniqueInv = None
        uniqueCnt = None

        # rearrange array as structured array if necessary
        if axis is None:
            b = a
        else:
            dType = np.dtype((np.void, a.dtype.itemsize * a.shape[1]))
            b = np.ascontiguousarray(a).view(dType)

        if version < '1.9.0':
            # npVersion below 1.9 dosn't allow return_counts and axis
            if return_counts or return_inverse:
                _, uniqueIdx, uniqueInv = np.unique(b, return_index=True,
                                                    return_inverse=True)
                if return_counts:
                    uniqueCnt = _uniqueFrequencies(uniqueIdx, uniqueInv)
                else:
                    uniqueCnt = None

            else:
                _, uniqueIdx = np.unique(b, return_index=True)
                uniqueInv = None
                uniqueCnt = None

        else:
            # we can use the inbuild return_counts-option
            uu = np.unique(b, return_index=True,
                           return_inverse=return_inverse,
                           return_counts=return_counts)

            uniqueIdx = uu[1]

            if return_inverse:
                # get otional return of unique inverse index
                uniqueInv = uu[2]

            if return_counts:
                # get optional return of unique counts
                uniqueCnt = uu[1 + return_inverse + 1]

        # rebuild unique (regular) array
        uniqueA = a[uniqueIdx]

        # to return correct order/number of requested outputs
        res = [uniqueA,]
        if return_index:
            res.append(uniqueIdx)
        if return_inverse:
            res.append(uniqueInv)
        if return_counts:
            res.append(uniqueCnt)
        return tuple(res)

    # check that numpy's unique takes at least five arguments otherwise use
    # replacement uniqueRows
    if len(inspect.getargspec(np.unique).args)<5:
        # we have 5 arguments only since version 1.13.0
        unique = uniqueRows
    else:
        unique = np.unique

try:
    from numpy.lib import NumpyVersion
except ImportError:
    class NumpyVersion(object):
        """Replacement for numpy.lib.NumpyVersion

        # implemented in numpy since 1.8.0
        Parse and compare numpy version strings.
        NumPy has the following versioning scheme (numbers given are examples;
        they can be > 9) in principle):
         - Released version: '1.8.0', '1.8.1', etc.
         - Alpha: '1.8.0a1', '1.8.0a2', etc.
         - Beta: '1.8.0b1', '1.8.0b2', etc.
         - Release candidates: '1.8.0rc1', '1.8.0rc2', etc.
         - Development versions: '1.8.0.dev-f1234afa' (git commit hash appended)
         - Development versions after a1: '1.8.0a1.dev-f1234afa',
                                          '1.8.0b2.dev-f1234afa',
                                          '1.8.1rc1.dev-f1234afa', etc.
         - Development versions (no git hash available): '1.8.0.dev-Unknown'

        Comparing needs to be done against a valid version string or other
        `NumpyVersion` instance. Note that all development versions of the same
        (pre-)release compare equal.
        .. versionadded:: 1.9.0


        Parameters
        ==========

        vstring ... the NumPy version string (``np.__version__``).


        Examples
        ========
         >>> from numpy.lib import NumpyVersion
         >>> if NumpyVersion(np.__version__) < '1.7.0':
         ...     print('skip')
         >>> # skip
         >>> NumpyVersion('1.7')  # raises ValueError, add ".0"
         Traceback (most recent call last):
             ...
         ValueError: Not a valid numpy version string

        @Note: Try to avoid checking the version. Better (and 'more pythonic')
        is to check whether the function in question exists and has the right
        arguments and does what you expect. Remember Python likes duck-typing:
        "If it walks like a duck and it quacks like a duck, then it must be a
        duck".
        """

        def __init__(self, vstring):
            import re

            self.vstring = vstring

            ver_main = re.match(r'\d[.]\d+[.]\d+', vstring)
            if not ver_main:
                raise ValueError("Not a valid numpy version string")

            self.version = ver_main.group()
            self.major, self.minor, self.bugfix = [
                int(x) for x in self.version.split('.')]
            if len(vstring) == ver_main.end():
                self.pre_release = 'final'
            else:
                alpha = re.match(r'a\d', vstring[ver_main.end():])
                beta = re.match(r'b\d', vstring[ver_main.end():])
                rc = re.match(r'rc\d', vstring[ver_main.end():])
                pre_rel = [m for m in [alpha, beta, rc] if m is not None]
                if pre_rel:
                    self.pre_release = pre_rel[0].group()
                else:
                    self.pre_release = ''

            self.is_devversion = bool(re.search(r'.dev', vstring))

        def _compare_version(self, other):
            """Compare major.minor.bugfix"""
            if self.major == other.major:
                if self.minor == other.minor:
                    if self.bugfix == other.bugfix:
                        vercmp = 0
                    elif self.bugfix > other.bugfix:
                        vercmp = 1
                    else:
                        vercmp = -1
                elif self.minor > other.minor:
                    vercmp = 1
                else:
                    vercmp = -1
            elif self.major > other.major:
                vercmp = 1
            else:
                vercmp = -1

            return vercmp

        def _compare_pre_release(self, other):
            """Compare alpha/beta/rc/final."""
            if self.pre_release == other.pre_release:
                vercmp = 0
            elif self.pre_release == 'final':
                vercmp = 1
            elif other.pre_release == 'final':
                vercmp = -1
            elif self.pre_release > other.pre_release:
                vercmp = 1
            else:
                vercmp = -1

            return vercmp

        def _compare(self, other):
            if not isinstance(other, (basestring, NumpyVersion)):
                raise ValueError("Invalid object to compare with NumpyVersion.")

            if isinstance(other, basestring):
                other = NumpyVersion(other)

            vercmp = self._compare_version(other)
            if vercmp == 0:
                # Same x.y.z version, check for alpha/beta/rc
                vercmp = self._compare_pre_release(other)
                if vercmp == 0:
                    # Same version and same pre-release, check if dev version
                    if self.is_devversion is other.is_devversion:
                        vercmp = 0
                    elif self.is_devversion:
                        vercmp = -1
                    else:
                        vercmp = 1

            return vercmp

        def __lt__(self, other):
            return self._compare(other) < 0

        def __le__(self, other):
            return self._compare(other) <= 0

        def __eq__(self, other):
            return self._compare(other) == 0

        def __ne__(self, other):
            return self._compare(other) != 0

        def __gt__(self, other):
            return self._compare(other) > 0

        def __ge__(self, other):
            return self._compare(other) >= 0

        def __repr(self):
            return "NumpyVersion(%s)" % self.vstring


def utf8Subs(keys, pos):
    """Super- and subscriptMapping to get UTF-characters

    Usage:
    ======
        >>> print('Bla' + utf8Subs('upper',0) + utf8Subs('lower',1))

    @param keys: string to be put in sub- or superscript

    @param pos: 0--> superscript, 1-->subscript

    @note: unavailable keys will be displayed as '?'
    """
    unicodeMap = {
         #           superscript     subscript
        '0'        : (u'\u2070',   u'\u2080'      ),
        '1'        : (u'\u00B9',   u'\u2081'      ),
        '2'        : (u'\u00B2',   u'\u2082'      ),
        '3'        : (u'\u00B3',   u'\u2083'      ),
        '4'        : (u'\u2074',   u'\u2084'      ),
        '5'        : (u'\u2075',   u'\u2085'      ),
        '6'        : (u'\u2076',   u'\u2086'      ),
        '7'        : (u'\u2077',   u'\u2087'      ),
        '8'        : (u'\u2078',   u'\u2088'      ),
        '9'        : (u'\u2079',   u'\u2089'      ),
        'a'        : (u'\u1d43',   u'\u2090'      ),
        'b'        : (u'\u1d47',   '?'           ),
        'c'        : (u'\u1d9c',   '?'           ),
        'd'        : (u'\u1d48',   '?'           ),
        'e'        : (u'\u1d49',   u'\u2091'      ),
        'f'        : (u'\u1da0',   '?'           ),
        'g'        : (u'\u1d4d',   '?'           ),
        'h'        : (u'\u02b0',   u'\u2095'      ),
        'i'        : (u'\u2071',   u'\u1d62'      ),
        'j'        : (u'\u02b2',   u'\u2c7c'      ),
        'k'        : (u'\u1d4f',   u'\u2096'      ),
        'l'        : (u'\u02e1',   u'\u2097'      ),
        'm'        : (u'\u1d50',   u'\u2098'      ),
        'n'        : (u'\u207f',   u'\u2099'      ),
        'o'        : (u'\u1d52',   u'\u2092'      ),
        'p'        : (u'\u1d56',   u'\u209a'      ),
        'q'        : ('?',        '?'           ),
        'r'        : (u'\u02b3',   u'\u1d63'      ),
        's'        : (u'\u02e2',   u'\u209b'      ),
        't'        : (u'\u1d57',   u'\u209c'      ),
        'u'        : (u'\u1d58',   u'\u1d64'      ),
        'v'        : (u'\u1d5b',   u'\u1d65'      ),
        'w'        : (u'\u02b7',   '?'           ),
        'x'        : (u'\u02e3',   u'\u2093'      ),
        'y'        : (u'\u02b8',   '?'           ),
        'z'        : ('?',        '?'           ),
        'A'        : (u'\u1d2c',   '?'           ),
        'B'        : (u'\u1d2e',   '?'           ),
        'C'        : ('?',        '?'           ),
        'D'        : (u'\u1d30',   '?'           ),
        'E'        : (u'\u1d31',   '?'           ),
        'F'        : ('?',        '?'           ),
        'G'        : (u'\u1d33',   '?'           ),
        'H'        : (u'\u1d34',   '?'           ),
        'I'        : (u'\u1d35',   '?'           ),
        'J'        : (u'\u1d36',   '?'           ),
        'K'        : (u'\u1d37',   '?'           ),
        'L'        : (u'\u1d38',   '?'           ),
        'M'        : (u'\u1d39',   '?'           ),
        'N'        : (u'\u1d3a',   '?'           ),
        'O'        : (u'\u1d3c',   '?'           ),
        'P'        : (u'\u1d3e',   '?'           ),
        'Q'        : ('?',        '?'           ),
        'R'        : (u'\u1d3f',   '?'           ),
        'S'        : ('?',        '?'           ),
        'T'        : (u'\u1d40',   '?'           ),
        'U'        : (u'\u1d41',   '?'           ),
        'V'        : (u'\u2c7d',   '?'           ),
        'W'        : (u'\u1d42',   '?'           ),
        'X'        : ('?',        '?'           ),
        'Y'        : ('?',        '?'           ),
        'Z'        : ('?',        '?'           ),
        '+'        : (u'\u207A',   u'\u208A'      ),
        '-'        : (u'\u207B',   u'\u208B'      ),
        '='        : (u'\u207C',   u'\u208C'      ),
        '('        : (u'\u207D',   u'\u208D'      ),
        ')'        : (u'\u207E',   u'\u208E'      ),
        ':alpha'   : (u'\u1d45',   '?'           ),
        ':beta'    : (u'\u1d5d',   u'\u1d66'      ),
        ':gamma'   : (u'\u1d5e',   u'\u1d67'      ),
        ':delta'   : (u'\u1d5f',   '?'           ),
        ':epsilon' : (u'\u1d4b',   '?'           ),
        ':theta'   : (u'\u1dbf',   '?'           ),
        ':iota'    : (u'\u1da5',   '?'           ),
        ':pho'     : ('?',        u'\u1d68'      ),
        ':phi'     : (u'\u1db2',   '?'           ),
        ':psi'     : (u'\u1d60',   u'\u1d69'      ),
        ':chi'     : (u'\u1d61',   u'\u1d6a'      ),
        ':coffee'  : (u'\u2615',   u'\u2615'      )
    }
    out = u''
    for key in keys:
        try:
            out = out + unicodeMap[key][pos]
        except:
            out = out + u'?'

    return out